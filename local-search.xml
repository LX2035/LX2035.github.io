<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/05/text/"/>
    <url>/2021/03/05/text/</url>
    
    <content type="html"><![CDATA[<p>@<a href="VHDL%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93">TOC</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color=#999AAA >FPGA作为提升处理性能的黑马，这些年越来越火热，不论对于未来是否从事这个方向的人来说，了解FPGA都是很有必要的，抱着学习的心态我学习了FPGA，这篇博文做记录</font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="一、-VHDL是什么？"><a href="#一、-VHDL是什么？" class="headerlink" title="一、 VHDL是什么？"></a>一、 VHDL是什么？</h1><h2 id="1-缩写"><a href="#1-缩写" class="headerlink" title="1. 缩写"></a>1. 缩写</h2><p>VHDL：Very High Speed Integrated Circuit Hardware Description Language</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><ol><li>传统的数字系统设计分为硬件设计、软件设计，VHDL打破了传统的软、硬件设计界限</li><li>类似C、C++代替汇编等语言一样，VHDL代替了原理图、逻辑状态图</li><li>电子系统设计者和EDA工具之间的桥梁</li><li>EDA工具及 HDL的流行，促使电子系统向集成化、大规模和高速度等方向发展<h2 id="3-VHDL与原理图描述的比较"><a href="#3-VHDL与原理图描述的比较" class="headerlink" title="3. VHDL与原理图描述的比较"></a>3. VHDL与原理图描述的比较</h2></li><li>VHDL具有较强的抽象描述能力，可进行系统行为级别的描述。描述更简洁，效率更高；</li><li>原理图描述必须给出完整的、具体的电路结构图，不能进行描象描述。描述繁杂，效率低；</li><li>VHDL描述与实现工艺无关；</li><li>原理图描述与实现工艺有关</li></ol><h2 id="4-VHDL语言特点"><a href="#4-VHDL语言特点" class="headerlink" title="4. VHDL语言特点"></a>4. VHDL语言特点</h2><ol><li>VHDL具有强大的语言结构，系统硬件抽象描述能力强、设计效率高；</li><li>VHDL语言可读性强，易于修改和发现错误；</li><li>VHDL具有丰富的仿真语句和库函数，可进行早期行为仿真，利于大系统的设计与验证；</li><li>VHDL设计与硬件电路关系不大；</li><li>VHDL设计不依赖于器件，与工艺无关 </li><li>移植性好；</li><li>VHDL体系符合TOP-DOWN和CE设计思想；</li><li>VHDL设计效率高，产品上市时间快，成本低；</li><li>易于ASIC实现</li></ol><h2 id="5-与其他语言比较"><a href="#5-与其他语言比较" class="headerlink" title="5. 与其他语言比较"></a>5. 与其他语言比较</h2><p>常用硬件描述语言有VHDL、Verilog和ABEL语言。VHDL起源于美国国防部的VHSIC，Verilog起源于集成电路的设计，ABEL则来源于可编程逻辑器件的设计。VHDL语言是一种高级描述语言，适用于行为级和RTL级的描述，最适于描述电路的行为；Verilog语言和ABEL语言是一种较低级的描述语言，适用于RTL级和门电路级的描述，最适于描述门级电路。 </p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="二、VHDL程序架构"><a href="#二、VHDL程序架构" class="headerlink" title="二、VHDL程序架构"></a>二、VHDL程序架构</h1><h2 id="VHDL基本结构"><a href="#VHDL基本结构" class="headerlink" title="VHDL基本结构"></a>VHDL基本结构</h2><ol><li>实体（Entity）</li><li>结构体（Architecture）</li><li>配置（Configuration）</li><li>库（Library）、程序包（Package）<br><img src="https://img-blog.csdnimg.cn/20201214222323776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Mzk2Njcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="1-实体-Entity"><a href="#1-实体-Entity" class="headerlink" title="1. 实体 Entity"></a>1. 实体 Entity</h2></li><li>作用：定义系统的输入输出接口</li><li><strong>用法格式：</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENTITY <span class="hljs-tag">&lt;<span class="hljs-name">entity_name</span>&gt;</span> IS<br>     Generic Declarations<br>     Port Declarations<br>END <span class="hljs-tag">&lt;<span class="hljs-name">entity_name</span>&gt;</span>; (1076-1987 version)<br>END ENTITY <span class="hljs-tag">&lt;<span class="hljs-name">entity_name</span>&gt;</span> ; (1076-1993 version)<br></code></pre></td></tr></table></figure><ul><li><p>Generic：确定实体或组件中定义的局部常数。模块化设计时多用于不同层次模块之间信息的传递，可从外部改变内部电路和规模，必须放在端口说明之前</p><p>Generic (</p><pre><code>       常数名称：类型 [：= 缺省值]      &#123;常数名称：类型 [：= 缺省值]&#125;     )；</code></pre><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">entity and2 is<br>         generic(risewidth: time:= 1 ns;fallwidth: time:= 1 ns);<br>         port(a1: in std_logic;a0: in std_logic;z0: out std_loigc);<br>end entity and2; <br></code></pre></td></tr></table></figure></li><li><p>端口声明：确定输入输出端口的数目和类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">Port （<br>            端口名称&#123;，端口名称&#125;：端口模式   数据类型；<br>                  …<br>            端口名称&#123;，端口名称&#125;：端口模式   数据类型<br>      ）；<br></code></pre></td></tr></table></figure><p>eg：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">port(a1: in std_logic; a0: in std_logic; z0: out std_loigc);<br></code></pre></td></tr></table></figure><ul><li>补充</li></ul><p>1.端口模式的分类：<br> in         输入型，<strong>此端口为只读型。</strong><br> out       输出型，<strong>此端口只能在实体内部对其赋值</strong><br> inout    输入输出型，<strong>既可读也可赋值</strong><br> buffer  缓冲型，<strong>与 out 相似，但可读</strong></p><p> 2.buffer、inout对比：<br>inout，输入输出双向端口，可读可写<br>buffer，为缓冲端口，可读可写，但要读入数据时，<strong>只允许内部回读内部产生的输出信号，即反馈</strong><br>buffer，驱动只有一个源，<strong>不允许多重驱动</strong>，驱动源可以是其它实体的缓冲端口，也可以是设计实体的内部信号源，但不与其它实体的输出端口、双向端口相连<br>buffer，仅仅是一个数据缓存器，<strong>不能用于IO输出</strong></p><p>3.数据类型：<br>指端口上流动数据的表达格式，为预先定义好的数据类型，如：bit、bit_vector、integer、real、std_logic、std_logic_vector 等</p><h2 id="2-结构体-Architecture"><a href="#2-结构体-Architecture" class="headerlink" title="2.结构体 Architecture"></a>2.结构体 Architecture</h2><ol><li>作用：<br>定义系统（或模块）的行为、元件及内部的连接关系，即描述其逻辑功能。</li><li>组成部分：</li></ol><p>-. 说明部分：对数据类型、常数、信号、子程序、元件等元素的说明<br>-. 逻辑功能描述部分：以各种不同的描述风格描述系统的逻辑功能。常见的有行为描述/数据流描述以及结构化描述<br>一个设计实体可有多个结构体，代表实体的多种实现方式。各个结构体的地位相同</p><p><img src="https://img-blog.csdnimg.cn/20201215130602940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Mzk2Njcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3. 语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">architecture  结构体名称  of   实体名称  is <br>      [说明语句]内部信号、常数、<br>                         数据类型、子程序（函数、过程）、 <br>                         元件等的说明；<br>begin<br>       [并行处理（功能描述）语句]；<br>end  [architecture] 结构体名称；<br></code></pre></td></tr></table></figure><p>注：同一实体的结构体不能同名。定义语句中的常数、信号不能与实体中的端口同名。</p><p>使用方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">entity test1 is<br>port(sig,count:in bit;<br>out1,out2:out bit);<br>end test1;<br><br>architecture Behavioral of test1 is<br>signal sig:bit;<br>constant <span class="hljs-keyword">const</span>:bit:=<span class="hljs-string">&#x27;1&#x27;</span>;<br>begin<br><br>end Behavioral;<br></code></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">architecture art2 of nand is<br> begin<br>      c&lt;=‘<span class="hljs-number">1</span>’ when (a=‘<span class="hljs-number">0</span>’) <span class="hljs-keyword">and</span> (b=‘<span class="hljs-number">0</span>’) <span class="hljs-keyword">else</span><br>            ‘<span class="hljs-number">1</span>’ when (a=‘<span class="hljs-number">0</span>’) <span class="hljs-keyword">and</span> (b=‘<span class="hljs-number">1</span>’) <span class="hljs-keyword">else</span><br>            ‘<span class="hljs-number">1</span>’ when (a=‘<span class="hljs-number">1</span>’) <span class="hljs-keyword">and</span> (b=‘<span class="hljs-number">0</span>’) <span class="hljs-keyword">else</span><br>            ‘<span class="hljs-number">0</span>’ when (a=‘<span class="hljs-number">1</span>’) <span class="hljs-keyword">and</span> (b=‘<span class="hljs-number">1</span>’) <span class="hljs-keyword">else</span><br>            ‘<span class="hljs-number">0</span>’;<br> end architecture art2;<br><br></code></pre></td></tr></table></figure><h2 id="4-库-Libraty-程序包-Package"><a href="#4-库-Libraty-程序包-Package" class="headerlink" title="4.库 Libraty 程序包 Package"></a>4.库 Libraty 程序包 Package</h2><ol><li><p>程序包定义：<br>已定义的常数、数据类型、元件（调用）说明、子程序的一个集合。</p></li><li><p>库定义：多个程序包构成库</p></li><li><p>两者目的：方便公共信息、资源的访问和共享<br>程序包的结构包括：程序包说明（包首）和程序包主体（包体）</p></li><li><p>程序包说明</p></li></ol><ul><li><p>语法：<br>package  程序包名  is</p><pre><code>          &#123;包说明项&#125;</code></pre><p>   end  程序包名；</p></li><li><p>包说明项：<br>use 语句（用来包括其它程序包）<br>类型说明、子类型说明、常量说明；<br>信号说明、子程序说明、元件说明<br>（程序包体仅用于子程序的描述，只有在程序包中要说明子程序时，程序包体才是必须的<br>）</p></li></ul><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">package seven is<br>           <span class="hljs-function">subtype segments is <span class="hljs-title">bit_vector</span><span class="hljs-params">(<span class="hljs-number">0</span> to <span class="hljs-number">6</span>)</span></span>;<br>           type bcd is range <span class="hljs-number">0</span> to <span class="hljs-number">9</span>;<br>end seven;<br>library work;<br>use work.seven.all;<br>entity decoder is<br>     port(input: in bcd;<br>             drive: out segments);<br>end decoder;<br>architecture art of decoder is<br>begin<br>with input select<br>            drive&lt;=B“<span class="hljs-number">1111110</span>” when <span class="hljs-number">0</span>,<br>                         B“<span class="hljs-number">0110000</span>” when <span class="hljs-number">1</span>,<br>                         B“<span class="hljs-number">1101101</span>” when <span class="hljs-number">2</span>,<br>                         B“<span class="hljs-number">1111001</span>” when <span class="hljs-number">3</span>,<br>                         B“<span class="hljs-number">0110011</span>” when <span class="hljs-number">4</span>,<br>                         B“<span class="hljs-number">1011011</span>” when <span class="hljs-number">5</span>,<br>                         B“<span class="hljs-number">1011111</span>” when <span class="hljs-number">6</span>,<br>                         B“<span class="hljs-number">1110000</span>” when <span class="hljs-number">7</span>,<br>                         B“<span class="hljs-number">1111111</span>” when <span class="hljs-number">8</span>,<br>                         B“<span class="hljs-number">1111011</span>” when <span class="hljs-number">9</span>,<br>                         B“<span class="hljs-number">0000000</span>” when others;<br> end architecture art;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>库：<br>STD库：包含的程序包为standard，定义最基本的数据类型，如bit，bit_vector ，boolean，integer，real，and time，其中的bit为二值系统（只有‘0’、‘1’）<br>IEEE库：定义了四个常用的程序包<br>std_logic_1164 (std_logic types &amp; related functions)<br>std_logic_arith (arithmetic functions)<br>std_logic_signed (signed arithmetic functions)<br>std_logic_unsigned (unsigned arithmetic functions)</p></li><li><p>库及程序包的使用：</p></li></ol><p>库及程序包的说明应放在实体单元前面<br>library   库名；            library  ieee；<br>use   库名．程序包名．项目名            use  ieee.std_logic_1164.all；<br>use   库名．程序包名．All；            use ieee.std_logic_unsigned.conv_integer;  </p><p>库及程序包的作用范围：仅限于所说明的设计实体（每一个设计实体都必须有自己完整的库及程序包说明语句） </p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="三、VHDL语言要素"><a href="#三、VHDL语言要素" class="headerlink" title="三、VHDL语言要素"></a>三、VHDL语言要素</h1><h2 id="1-四类语言要素："><a href="#1-四类语言要素：" class="headerlink" title="1.四类语言要素："></a>1.四类语言要素：</h2><h3 id="数据对象（Data-Object）"><a href="#数据对象（Data-Object）" class="headerlink" title="数据对象（Data Object）"></a>数据对象（Data Object）</h3><ol><li>变量（Variable）</li></ol><p><strong>物理含义：</strong><br>暂存某些值的载体，常用于描述算法<br>局部量，定义于process、function、procedure<br><strong>具体说明：</strong><br>变量说明格式<br>variable  变量名：数据类型    约束条件：= 表达式；<br>如：variable  a, b : bit;<br>        variable  count : integer range 0 to 255 := 10;<br>局部量，只能在进程和子程序中定义、使用，其作用范围仅局限于定义变量的进程和子程序中。<br>变量的初值可用于仿真，但综合时被忽略</p><ol start="2"><li>常量（Constant）</li></ol><p><strong>物理含义：</strong><br>电源、地、恒定逻辑值等<br>全局量，可定义于上面两种场合<br><strong>常量说明：</strong><br>对某一个常量名赋予一个固定的值<br>constant  常数名：数据类型：= 表达式；<br>constant  data: bit_vector(3 downto 0):=“1010”<br>        constant  width: integer: = 8；<br>        constant  x: new_bit: = ‘x’；<br>常量数据类型必须与表达式的数据类型一致<br>常量是全局量，其作用范围取决于常量被定义的位置。</p><ol start="3"><li>信号（Signal）</li></ol><p><strong>物理含义</strong>：<br>是硬件连接线，端口<br>全局量，定义于architecture、package、entitiy<br><strong>具体说明：</strong><br>电子硬件系统运行的基本特性<br>各部分电路工作的并行特性；<br>信号传输过程中的延时特性；<br>多驱动源的总线特性；<br>时序电路中触发器的记忆特性<br>信号是电子系统内部硬件连接和硬件特性的抽象表示：<br>signal  信号名：数据类型    约束条件：＝ 表达式；<br>如：signal  s2 : std_logic_vector(15 downto 0);<br>综合时初值被忽略<br>信号是全局量，可在结构体、实体、块中 说明和使用信号<br>在进程和子程序中只能使用信号，不能说明信号<br>信号与端口的区别：信号本身无方向，可读可写；端口是一种有方向的隐形信号</p><h3 id="数据类型（Data-Type）"><a href="#数据类型（Data-Type）" class="headerlink" title="数据类型（Data Type）"></a>数据类型（Data Type）</h3><p> <strong>VHDL是一种强数据类型语言</strong><br>设计实体中每一个常数、信号、变量、函数以及设定的各种参量都必须事先说明数据类型<br>同类型才能互相传递和作用</p><h3 id="操作数（Operands）"><a href="#操作数（Operands）" class="headerlink" title="操作数（Operands）"></a>操作数（Operands）</h3><p>操作对象常量或变量</p><h3 id="操作符（Operator）"><a href="#操作符（Operator）" class="headerlink" title="操作符（Operator）"></a>操作符（Operator）</h3><p><strong>分类：</strong></p><ol><li><p>逻辑操作符（Logical Operator）<br>6种：and、or、nand、nor、xor、not<br>操作数类型必须相同，可为如下类型：bit、bit_vector、std_logic、std_logic_vector、boolean，数组操作数的维数、大小必须相同</p></li><li><p>关系操作符（Relational Operator） </p><p>用于比较相同父类的两个操作数，返回boolean值<br>6 种：=、/=、&lt;、&lt;=、&gt;、&gt;=</p></li><li><p>算术操作符（Arithmetic Operator）</p><p>加操作符“+”、减操作符“-”<br>串联（并置）操作符“&amp;”：通过连接操作数来建立新的数组。操作数可以是一个数组或数组中的一个元素</p></li><li><p>重载操作符（Overloading Operator）</p><p>仅有一个操作数的操作符，包括：“+”、“-”<br>乘除操作符<br>用于整数类型：“*”、“/”、“mod”、“rem”<br>综合的限制：“/ ”、“mod”、“rem” 三种操作符的右操作数必须为 2 的正整数次幂，即 2n。实际电路用移位实现<br>A rem B 余数运算符，利用操作数A决定结果的正负号；A mod B 取模运算符，利用操作数B决定结果的正负号</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"></li></ol><h1 id="四、VHDL顺序语句"><a href="#四、VHDL顺序语句" class="headerlink" title="四、VHDL顺序语句"></a>四、VHDL顺序语句</h1><ol><li><p>执行顺序与书写顺序一致，与传统软件设计语言的特点相似</p></li><li><p>顺序语句只能用在进程与子程序中</p></li><li><p>可描述组合逻辑、时序逻辑</p></li><li><p>常用的顺序描述语句：<br>赋值语句； if语句；case语句；loop语句；<br>next语句；exit语句；子程序；return语句；<br>wait语句；null语句</p></li></ol><p>注明：</p><ol><li>变量赋值和信号赋值<br>赋值标识符的不同<br>变量：= 表达式；<br>信号 &lt; = 表达式</li><li>硬件实现的功能不同<br>信号代表电路单元、功能模块间的互联，代表实际的硬件连线<br>变量代表电路单元内部的操作，代表暂存的临时数据；</li><li>有效范围的不同<br>信号：全局量，程序包、实体、结构体<br>变量：局部量，进程、子程序</li><li>赋值行为的不同<br>信号赋值延迟更新数值<br>变量赋值立即更新数值</li><li>信号的多次赋值<br>一个进程：最后一次赋值有效<br>多个进程：多源驱动，线与、线或、三态<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"></li></ol><h1 id="五、VHDL并发语句"><a href="#五、VHDL并发语句" class="headerlink" title="五、VHDL并发语句"></a>五、VHDL并发语句</h1><p><img src="https://img-blog.csdnimg.cn/20210219141433365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Mzk2Njcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>常用的并发描述语句有：进程（process）语句、块（block）语句、顺序描述语句的并行版本、并行过程调用语句、元件例化语句、生成语句 </p><ol><li>进程（process）语句最具VHDL语言特色。提供了一种用算法描述硬件行为的方法：<br>进程与进程，或其它并发语句之间的并发性<br>进程内部的顺序性<br>进程的启动与挂起<br>进程内要读取的所有敏感信号（包括端口）的列表。每一个敏感信号的变化，都将启动进程。如果有 wait 语句，则不允许有敏感信号表。</li><li>块语句<br>块语句将一系列并行描述语句进行组合，目的是改善并行语句及其结构的可读性。可使结构体层次鲜明，结构清晰</li><li>并行信号赋值语句包括三种<br>简单并行信号赋值<br>条件信号赋值<br>选择信号赋值<br>赋值目标必须是信号，与其它并行语句同时执行，与书写顺序及是否在块语句中无关，每一信号赋值语句等效于一个进程语句，所有输入信号的变化都将启动该语句的执行</li></ol><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color=#999AAA >以上就是今天要讲的内容，本文仅仅简单总结了FPGA的基本语法，更多的提高还是要多做实践</p><p>原文网页：<a href="https://www.jeckxu.cn/post/747c104.html">我的个人博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>blog 02</title>
    <link href="/2021/03/01/20200301/"/>
    <url>/2021/03/01/20200301/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS系统"><a href="#ROS系统" class="headerlink" title="ROS系统"></a>ROS系统</h1><h2 id="1-可自定义通信协议实现实现上下位机通信"><a href="#1-可自定义通信协议实现实现上下位机通信" class="headerlink" title="1.可自定义通信协议实现实现上下位机通信"></a>1.可自定义通信协议实现实现上下位机通信</h2><h2 id="2-本质上也是个嵌入式系统，发布节点等（类似task）"><a href="#2-本质上也是个嵌入式系统，发布节点等（类似task）" class="headerlink" title="2.本质上也是个嵌入式系统，发布节点等（类似task）"></a>2.本质上也是个嵌入式系统，发布节点等（类似task）</h2><h2 id="3-ros下将任务分包"><a href="#3-ros下将任务分包" class="headerlink" title="3.ros下将任务分包"></a>3.ros下将任务分包</h2><ul><li><h3 id="1-网络通信-同客户端连接（web页面），直接用处理器上的wifi网卡"><a href="#1-网络通信-同客户端连接（web页面），直接用处理器上的wifi网卡" class="headerlink" title="1.网络通信-同客户端连接（web页面），直接用处理器上的wifi网卡"></a>1.网络通信-同客户端连接（web页面），直接用处理器上的wifi网卡</h3></li><li><h3 id="2-人脸数据库识别-读取内存的人脸数据库进行实时识别"><a href="#2-人脸数据库识别-读取内存的人脸数据库进行实时识别" class="headerlink" title="2.人脸数据库识别-读取内存的人脸数据库进行实时识别"></a>2.人脸数据库识别-读取内存的人脸数据库进行实时识别</h3></li><li><h3 id="3-ros下的建图导航与测距"><a href="#3-ros下的建图导航与测距" class="headerlink" title="3.ros下的建图导航与测距"></a>3.ros下的建图导航与测距</h3><ul><li><h4 id="1-首先需要手动绘制环境地图"><a href="#1-首先需要手动绘制环境地图" class="headerlink" title="1.首先需要手动绘制环境地图"></a>1.首先需要手动绘制环境地图</h4></li><li><h4 id="2-算法本身可对地图进行修改（指在运行过程中的）"><a href="#2-算法本身可对地图进行修改（指在运行过程中的）" class="headerlink" title="2.算法本身可对地图进行修改（指在运行过程中的）"></a>2.算法本身可对地图进行修改（指在运行过程中的）</h4></li><li><h4 id="3-算法需要获取机器人位置，解算出位姿，传感器精度影响系统精度"><a href="#3-算法需要获取机器人位置，解算出位姿，传感器精度影响系统精度" class="headerlink" title="3.算法需要获取机器人位置，解算出位姿，传感器精度影响系统精度"></a>3.算法需要获取机器人位置，解算出位姿，传感器精度影响系统精度</h4></li><li><h4 id="4-采用深度相机可获取需要的距离等信息，进而解算出环境信息"><a href="#4-采用深度相机可获取需要的距离等信息，进而解算出环境信息" class="headerlink" title="4.采用深度相机可获取需要的距离等信息，进而解算出环境信息"></a>4.采用深度相机可获取需要的距离等信息，进而解算出环境信息</h4></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Welcome to my blog</title>
    <link href="/2021/02/26/hello-world/"/>
    <url>/2021/02/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>春风桃李一杯酒，江湖夜雨十年灯</p><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#一个爱好电子的小码农</span><br><span class="hljs-comment">#喜欢单片机，机器人设计，传感器等</span><br></code></pre></td></tr></table></figure><h3 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#主题采用 Hexo Fluid</span><br></code></pre></td></tr></table></figure><p>链接: <a href="https://github.com/fluid-dev/hexo-theme-fluid">server</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
